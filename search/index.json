[{"content":"专题二 二分法 102400226 石华波\tVjudge账号:DustLi\n问题一\t二分查找 问题陈述 输入一个整数 n和 n个整数，保证这 n个整数已经按照从小到大进行排序。\n然后输入一个整数 q（ q≤100000 ）代表 q次查询。接下来 q行，每行含有一个整数 m，代表一次查询。对于每次查询，使用二分查找判断 m是否在之前输入的 n个整数中出现过。如果出现，输出一行 \u0026ldquo;Yes\u0026rdquo;，否则输出 \u0026ldquo;No 。\n解题思路 基本的二分查找，直接套板即可。\nAC代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int n; cin\u0026gt;\u0026gt;n; int array[n]; for(int i=0;i\u0026lt;n;i++) { cin\u0026gt;\u0026gt;array[i]; } int q; cin\u0026gt;\u0026gt;q; while(q--) { int m; cin\u0026gt;\u0026gt;m; int beg=0,end=n-1,mid=0; while(beg\u0026lt;=end) { mid=(beg+end)/2; if(array[mid]==m) break; if(array[mid]\u0026lt;m) beg=mid+1; else end=mid-1; } if(array[mid]==m) cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; } return 0; } 问题二\tA-B数对 问题陈述 给出一串正整数数列以及一个正整数 C，要求计算出所有满足 A−B=C的数对的个数（不同位置的数字一样的数对算不同的数对）。\n解题思路 解题时并未联系到二分查找，而是使用Hash表，遍历数组，当HASH表中存在A=B+C时，答案加上A出现的次数。\nAC代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include\u0026lt;iostream\u0026gt; #include\u0026lt;unordered_map\u0026gt; using namespace std; int main(){ int N,C; int tag; long long ans=0; cin\u0026gt;\u0026gt;N\u0026gt;\u0026gt;C; int nums[N]; unordered_map\u0026lt;int,int\u0026gt; numcnt; for(int i=0;i\u0026lt;N;i++) { cin\u0026gt;\u0026gt;nums[i]; numcnt[nums[i]]++; } for(int i=0;i\u0026lt;N;i++) { tag=nums[i]+C; ans+=numcnt[tag]; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } 问题三\t分巧克力 问题陈述 儿童节那天有 K 位小朋友到小明家做客。小明拿出了珍藏的巧克力招待小朋友们。\n小明一共有 NN 块巧克力，其中第 i 块是 Hi×Wi的方格组成的长方形。\n为了公平起见，小明需要从这 N 块巧克力中切出 K 块巧克力分给小朋友们。切出的巧克力需要满足：\n形状是正方形，边长是整数。 大小相同。 例如一块 6×5的巧克力可以切出 6 块 2×2的巧克力或者 2块 3×3的巧克力。\n当然小朋友们都希望得到的巧克力尽可能大，你能帮小明计算出最大的边长是多少么？\n解题思路 题目要求每块巧克力大小相同，而对于一块H[i]*W[i]的巧克力，最多能切出边长为i的巧克力(H[i]/i)*(W[i]/i)份。\n使用二分法，由题意可知最大边长不会超过已知Hi、Wi最大值中较小的那个，故以该值为上界，1为下界，当可切出的块数大于等于K时更新下界，否则更新上界。\nAC代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include\u0026lt;iostream\u0026gt; #include\u0026lt;climits\u0026gt; using namespace std; int main(){ int N,K; cin\u0026gt;\u0026gt;N\u0026gt;\u0026gt;K; int H[N],W[N]; int Max=INT_MIN; for(int i=0;i\u0026lt;N;i++) { cin\u0026gt;\u0026gt;H[i]\u0026gt;\u0026gt;W[i]; Max=max(Max,min(H[i],W[i])); } int Min=1; int mid; int cnt; while(Min\u0026lt;Max) { mid=(Min+Max+1)/2; cnt=0; for(int i=0;i\u0026lt;N;i++) { cnt+=(H[i]/mid)*(W[i]/mid); } if(cnt\u0026gt;=K) Min=mid; else Max=mid-1; } cout\u0026lt;\u0026lt;Min\u0026lt;\u0026lt;endl; return 0; } 问题4\t卡牌 问题陈述 这天，小明在整理他的卡牌。\n他一共有 n 种卡牌，第 ii 种卡牌上印有正整数数 i(i∈[1,n]), 且第 i种卡牌现有 ai张。\n而如果有 n 张卡牌，其中每种卡牌各一张，那么这 n 张卡牌可以被称为一套牌。小明为了凑出尽可能多套牌，拿出了 m 张空白牌, 他可以在上面写上数 i，将其当做第 i 种牌来凑出套牌。然而小明觉得手写的牌不太美观，决定第 i种牌最多手写 bi张。\n请问小明最多能凑出多少套牌?\n解题思路 首先，十年OI一场空，不开LongLong见祖宗！\n同样是用二分法查找最多能凑出的牌数，此处上界可以是max(Right,b[i]+a[i])，但对结果影响不大，故没有进行修改，使用了与上一题不同的二分板子。\n以1为下界，一个足够大的数1e7为上界，Check函数用于检查是否能够凑出mid套牌，如果mid-a[i]\u0026gt;b[i]，说明无论如何此种牌都无法凑到mid张，可直接return 0,循环结束后将sum与m比较，如若sum小于等于m则说明可以凑出mid套牌，反之不然。\nAC代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include\u0026lt;iostream\u0026gt; #include\u0026lt;climits\u0026gt; #define ll long long using namespace std; const ll N=2e5+10; ll n,m; ll a[N],b[N]; ll Check(ll x); int main() { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(ll i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;a[i]; for(ll i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;b[i]; ll Left=0,Right=1e7; while(Left\u0026lt;Right) { ll mid=(Right+Left+1)/2; if(Check(mid)) Left=mid; else Right=mid-1; } cout\u0026lt;\u0026lt;Right\u0026lt;\u0026lt;endl; return 0; } ll Check(ll x) { ll sum=0; for(ll i=0;i\u0026lt;n;i++) { if(x-a[i]\u0026gt;b[i]) return 0; sum+=x-a[i]\u0026gt;0?x-a[i]:0; } return sum\u0026lt;=m; } 问题五\t书的复制 问题陈述 现在要把 m 本有顺序的书分给 k个人复制（抄写），每一个人的抄写速度都一样，一本书不允许给两个（或以上）的人抄写，分给每一个人的书，必须是连续的，比如不能把第一、第三、第四本书给同一个人抄写。\n现在请你设计一种方案，使得复制时间最短。复制时间为抄写页数最多的人用去的时间。\n解题思路 二分法此处不表，与上文类似。\n复制时间即抄写页数最多的人所抄页数，该值最大为所有书页码之和，最小为页码数最多那本书的页码数，以此为上下界。\nCheck函数中，检查抄的页数加上当前书的页数是否超过mid（所求复制时间），是则换人，否则继续，最后比较所需人数与实际人数，若所需人数小于等于实际人数则可行，反之不然。\n在输出答案时，选择从后往前遍历，即让后面的人多抄以达到前面的人少抄的效果，记录下每个人的结束书号，第一个人的起始书号为1，最后一个人的结束书号为n，当前人的起始书号为上一个人的结束书号+1。\nAC代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include\u0026lt;iostream\u0026gt; #include\u0026lt;climits\u0026gt; #define ll long long using namespace std; int Check(int upp); int book,people; int books[502]; int main() { cin\u0026gt;\u0026gt;book\u0026gt;\u0026gt;people; int left=0,right=0; for(int i=1;i\u0026lt;=book;i++) { cin\u0026gt;\u0026gt;books[i]; right+=books[i]; left=max(left,books[i]); } int mid=0; while(left+1\u0026lt;right) { mid=(left+right)/2; if(Check(mid)) right=mid; else left=mid; } int last[505],cnt=1; last[1]=book+1; last[people+1]=1; int pages=0; for(int i=book;i\u0026gt;0;i--) { if(pages+books[i]\u0026gt;right) { pages=0; last[++cnt]=i+1; } pages+=books[i]; } for(int i=people;i\u0026gt;0;i--) { cout\u0026lt;\u0026lt;last[i+1]\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;last[i]-1\u0026lt;\u0026lt;endl; } return 0; } int Check(int upp) { int pcnt=1,pages=0; for(int i=book;i\u0026gt;0;i--) { if(pages+books[i]\u0026gt;upp) pages=0,pcnt++; pages+=books[i]; } return pcnt\u0026lt;=people; } 问题六\t青蛙过河 小青蛙住在一条河边，它想到河对岸的学校去学习。小青蛙打算经过河里的石头跳到对岸。\n河里的石头排成了一条直线，小青蛙每次跳跃必须落在一块石头或者岸上。不过，每块石头有一个高度，每次小青蛙从一块石头起跳，这块石头的高度就会下降 1，当石头的高度下降到 0时小青蛙不能再跳到这块石头上（某次跳跃后使石头高度下降到 0是允许的)。\n小青蛙一共需要去学校上 x天课，所以它需要往返 2x次。当小青蛙具有一个跳跃能力 y时，它能跳不超过 y的距离。\n请问小青蛙的跳跃能力至少是多少才能用这些石头上完 x次课。\n解题思路 一只青蛙往返2x次\u0026lt;=\u0026gt;一只青蛙单向过河2x次\u0026lt;=\u0026gt;2x只青蛙单向过河1次。\n在第i次跳越中，这些青蛙必将落在[i,y+i-1]的区间中，故每个这样的区间中石头高度之和必须大于等于2x，此为必要性。\n接下来说明充分性：当青蛙们在[i,y+i-1]的区间内上落脚时，令落在石头i上的青蛙向前跳跃[1,y]格，则此时所有的青蛙都处于[i+1,y+1]区间中，由于每个区间的石头高度之和均大于等于2x，所以青蛙均能顺利落脚。显然，这2x只青蛙可以在[1,y]上落脚，那么以此类推，他们就可以在[2,y+1]、[3,y+2]……上落脚，故所有青蛙均能过河。\n但如果每次都以H[i]+\u0026hellip;+H[y+i-1]的方式计算区间高度和，用时就太久了，故计算从石头1到石头n的高度和Sum[i]，每次只需令区间端点的高度和相减即可。\nAC代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include\u0026lt;iostream\u0026gt; #include\u0026lt;climits\u0026gt; #define ll long long using namespace std; ll Check(ll y); const ll N=1e5+1; ll width,days; ll H[N],Sum[N]={0}; int main() { cin\u0026gt;\u0026gt;width\u0026gt;\u0026gt;days; days*=2; for(ll i=1;i\u0026lt;width;i++) { cin\u0026gt;\u0026gt;H[i]; Sum[i]=Sum[i-1]+H[i]; } ll left=1,right=width; while(left\u0026lt;right) { ll mid=(left+right)/2; if(Check(mid)) right=mid; else left=mid+1; } cout\u0026lt;\u0026lt;left\u0026lt;\u0026lt;endl; return 0; } ll Check(ll y) { for(ll i=y;i\u0026lt;width;i++) { if(Sum[i]-Sum[i-y]\u0026lt;days) return 0; } return 1; } 学习总结 本专题内容主要为二分法的应用，通过学习，解决了两道绿题，提高了自己的能力。\n","date":"2025-01-26T00:00:00Z","permalink":"https://DustLi-DC.github.io/p/topic-two/","title":"专题二 二分法"},{"content":"专题一 学习C++ 102400226 石华波 Vjudge账号:DustLi\n问题一\tLong 问题陈述 对于一个正整数X，级别为X 的 龙字符串 是一个长度为 (X+3)的字符串，由一个 L、X 次出现的 o、一个 n 和一个 g 按此顺序排列而成。\n给定一个正整数N。打印级别为N 的龙字符串。 注意，大写字母和小写字母是有区别的。\n约束条件 1≤N≤20241≤N≤2024 N是一个整数。 解题思路 读取整数N后，输出L，再通过循环输出N个o，最后输出n、g即可，AC代码：\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int N; cin\u0026gt;\u0026gt;N; cout\u0026lt;\u0026lt;\u0026#39;L\u0026#39;; while(N--) cout\u0026lt;\u0026lt;\u0026#39;o\u0026#39;; cout\u0026lt;\u0026lt;\u0026#34;ng\u0026#34;\u0026lt;\u0026lt;endl; return 0; } 问题二\tYES or YES？ 问题陈述 有一个长度为 3 的字符串 s，由大写和小写英文字母组成。检查它是否等于 \u0026ldquo;YES\u0026rdquo;（不带引号），其中每个字母可以是任意大小写。例如，\u0026ldquo;yES\u0026rdquo;、\u0026ldquo;Yes\u0026rdquo;、\u0026ldquo;yes\u0026rdquo; 都是允许的。\n解题思路 逐个判断字符是否为\u0026rsquo;y\u0026rsquo;、\u0026lsquo;Y\u0026rsquo;……即可，AC代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { int N; cin\u0026gt;\u0026gt;N; while(N--) { string s; cin\u0026gt;\u0026gt;s; if(s[0]!=\u0026#39;y\u0026#39;\u0026amp;\u0026amp;s[0]!=\u0026#39;Y\u0026#39;) cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; else if(s[1]!=\u0026#39;e\u0026#39;\u0026amp;\u0026amp;s[1]!=\u0026#39;E\u0026#39;) cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; else if(s[2]!=\u0026#39;s\u0026#39;\u0026amp;\u0026amp;s[2]!=\u0026#39;S\u0026#39;) cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; } return 0; } 问题三\tEven? Odd? G 问题陈述 Bessie那惨无人道的二年级老师搞了一个有 N 个正整数 I 的表叫Bessie去判断“奇偶性”（这个词语意思向二年级的学生解释，就是“这个数是单数，还是双数啊？”）。Bessie被那个表的长度深深地震惊到了，竟然跟栋栋的泛做表格一样多道题！！！毕竟她才刚刚学会数数啊。\n写一个程序读入N个整数，如果是双数，那么在单立的一行内输出\u0026quot;even\u0026quot;，如果是单数则类似地输出\u0026quot;odd\u0026quot;.\n数据范围：每个正整数不超过 10^60\n解题思路 数据范围远超int 或者long long能表示的范围，但题目仅要求判断奇偶，故以string的方式读入，判断最后一位的奇偶即可。幸运的是，数字的ASCII码的奇偶性与其本身一致，故不需要额外进行处理，AC代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { int N; cin\u0026gt;\u0026gt;N; while(N--) { string s; cin\u0026gt;\u0026gt;s; if(s[s.length()-1]%2) cout\u0026lt;\u0026lt;\u0026#34;odd\u0026#34;\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;even\u0026#34;\u0026lt;\u0026lt;endl; } return 0; } 问题4\tProblem Generator 问题陈述 Vlad计划下个月举办m轮比赛。每一轮比赛应包含难度等级为\u0026rsquo;A\u0026rsquo;, \u0026lsquo;B\u0026rsquo;, \u0026lsquo;C\u0026rsquo;, \u0026lsquo;D\u0026rsquo;, \u0026lsquo;E\u0026rsquo;, \u0026lsquo;F\u0026rsquo;, 和 \u0026lsquo;G\u0026rsquo; 的一个问题。\nVlad已经准备了n个问题，其中第i个问题的难度等级为a(i)。可能这些问题数量不够，所以他可能需要再想出一些问题。\nVlad希望尽可能少地想出问题，因此他请你找出他需要想出的问题的最少数量，以便举办m轮比赛。\n例如，如果m=1，n=10，a= \u0026lsquo;BGECDCBDED\u0026rsquo;，那么他需要想出两个问题：一个难度等级为\u0026rsquo;A\u0026rsquo;，一个难度等级为\u0026rsquo;F\u0026rsquo;。\n解题思路 依题意，每种问题需要m个，故读入m、n，计算每种问题已有数量和总共所需之差再求和即可（缺少的问题\u0026lt;0的不计），AC代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int t; cin\u0026gt;\u0026gt;t; while(t--) { int n; int m; char c; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; int cnt[]={m,m,m,m,m,m,m}; int ans=0; while(n--) { cin\u0026gt;\u0026gt;c; cnt[c-65]--; } for(int i=0;i\u0026lt;7;i++) if(cnt[i]\u0026gt;0) ans+=cnt[i]; cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } 问题五\trules 问题陈述 小 A 制定了一些规则，每条规则有一个代号，代号为不超过 10^9的非负整数。\n小 A 的国家有 n位居民，每位居民每天会且仅会遵守 1条规则。小 A 记录了 m天里每天每位居民遵守的规则代号。\n现在小 A 想要考察代号为 k的规则是否符合民意，具体考察方法如下：\n如果在某一天里，有大于等于一半的人遵守了规则 k，那么小 A 认为在这一天规则 k是符合民意的。 如果在大于等于一半的天数里，规则 k符合民意，那么他会认为规则 k是正确的。否则，他会认为规则 k是错误的。 如果小 A 的规则 k是正确的，请你输出 YES，否则请你输出 NO。\n解题思路 分别计算每一天遵循该规则的居民数量是否大于等于总数的一半，最后再计算符合民意的天数是否大于等于m的一半即可（实现方法使用的是将遵循规则的居民数量、符合民意的天数乘以2与总居民数、m进行比较，不需要引入float类型，乘法比除法更快），AC代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int n,m,k; int cntt=0; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; for(int z=0;z\u0026lt;m;z++) { int cntd=0; for(int i=0;i\u0026lt;n;i++) { int d; cin\u0026gt;\u0026gt;d; cntd += d==k; } cntt += 2*cntd\u0026gt;=n; } if(2*cntt\u0026gt;=m) cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; return 0; } 问题六\tMany Replacement 问题陈述 给定一个长度为 N的字符串 S，由小写英文字母组成。\n你将对字符串 S 执行 Q 次操作。 第 i次操作 (1≤i≤Q)由一对字符 (c(i),d(i)) 表示，对应以下操作：\n将字符串 S中所有字符 c(i)替换为字符 d(i)。 在所有操作完成后，打印字符串 S。\n约束条件 1≤N≤2×10^5 S是一个长度为 N的字符串，由小写英文字母组成。 1≤Q≤2×10^5 c(i)和 d(i)是小写英文字母 (1≤i≤Q) N和 Q是整数。 解题思路 在字符串长度较长的情况下，每次都遍历字符串进行修改是不现实的（很有可能会TLE）。发现经过多次交换后，每个字母对应映射到另一字母，那么维护一个字母表（初始映射到自身），每次对字母表的映射进行修改，在最后再遍历字符串进行修改即可，AC代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { int N; string s; int Q; cin\u0026gt;\u0026gt;N\u0026gt;\u0026gt;s\u0026gt;\u0026gt;Q; char Letters[26]; for(int i=0;i\u0026lt;26;i++) Letters[i]=i+\u0026#39;a\u0026#39;; while(Q--) { char c,d; cin\u0026gt;\u0026gt;c\u0026gt;\u0026gt;d; for(int i=0;i\u0026lt;26;i++) { if(Letters[i]==c) { Letters[i]=d; } } } for(int i=0;i\u0026lt;N;i++) { s[i]=Letters[s[i]-\u0026#39;a\u0026#39;]; } cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;endl; return 0; } 问题七\t更好的交换 问题陈述 小 S 有一个奇怪的机关拼图。这个拼图可以看作一个 n行 n列的方阵 A，第 i行第 j列的位置上有一个正整数 A(i,j)。\n与寻常拼图不同的是，这个机关拼图上的数字不能随意移动，必须按照如下规则之一操作：\n选择拼图上的第 x行和第 y行，交换这两行； 选择拼图上的第 x列和第 y列，交换这两列。 为了复原这个拼图，小 S 将会操作共 m次，每次操作格式如下：\n1 x y，表示交换第 x行和第 y行； 0 x y，表示交换第 x列和第 y列； 请你输出复原后的拼图。\n解题思路 发现并不需要实际地交换行和列，只需要维护两个数组Row、Col，对数组中行与列映射代表的行与列关系进行修改即可，与上一题其实类似。AC代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; using namespace std; int Matrix[1002][1002]; int Row[1002],Col[1002]; int main() { int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++) { for(int j=1;j\u0026lt;=n;j++) { cin\u0026gt;\u0026gt;Matrix[i][j]; } } for(int i=1;i\u0026lt;=n;i++) Row[i]=Col[i]=i; while(m--) { int op,x,y; cin\u0026gt;\u0026gt;op\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; if(op) swap(Row[x],Row[y]); else swap(Col[x],Col[y]); } for(int i=1;i\u0026lt;=n;i++) { for(int j=1;j\u0026lt;=n;j++) { cout\u0026lt;\u0026lt;Matrix[Row[i]][Col[j]]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; } return 0; } 学习总结 本专题内容主要为C++基础语法，通过学习，对时间复杂度和空间复杂度的计算有了更深入的了解，对STL的内容有了了解。\n","date":"2025-01-23T00:00:00Z","permalink":"https://DustLi-DC.github.io/p/topic-one/","title":"专题一 学习C++"}]