[{"content":"专题一 学习C++ 102400226 石华波 Vjudge账号:DustLi\n问题一\tLong 问题陈述 对于一个正整数X，级别为X 的 龙字符串 是一个长度为 (X+3)的字符串，由一个 L、X 次出现的 o、一个 n 和一个 g 按此顺序排列而成。\n给定一个正整数N。打印级别为N 的龙字符串。 注意，大写字母和小写字母是有区别的。\n约束条件 1≤N≤20241≤N≤2024 N是一个整数。 解题思路 读取整数N后，输出L，再通过循环输出N个o，最后输出n、g即可，AC代码：\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int N; cin\u0026gt;\u0026gt;N; cout\u0026lt;\u0026lt;\u0026#39;L\u0026#39;; while(N--) cout\u0026lt;\u0026lt;\u0026#39;o\u0026#39;; cout\u0026lt;\u0026lt;\u0026#34;ng\u0026#34;\u0026lt;\u0026lt;endl; return 0; } 问题二\tYES or YES？ 问题陈述 有一个长度为 3 的字符串 s，由大写和小写英文字母组成。检查它是否等于 \u0026ldquo;YES\u0026rdquo;（不带引号），其中每个字母可以是任意大小写。例如，\u0026ldquo;yES\u0026rdquo;、\u0026ldquo;Yes\u0026rdquo;、\u0026ldquo;yes\u0026rdquo; 都是允许的。\n解题思路 逐个判断字符是否为\u0026rsquo;y\u0026rsquo;、\u0026lsquo;Y\u0026rsquo;……即可，AC代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { int N; cin\u0026gt;\u0026gt;N; while(N--) { string s; cin\u0026gt;\u0026gt;s; if(s[0]!=\u0026#39;y\u0026#39;\u0026amp;\u0026amp;s[0]!=\u0026#39;Y\u0026#39;) cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; else if(s[1]!=\u0026#39;e\u0026#39;\u0026amp;\u0026amp;s[1]!=\u0026#39;E\u0026#39;) cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; else if(s[2]!=\u0026#39;s\u0026#39;\u0026amp;\u0026amp;s[2]!=\u0026#39;S\u0026#39;) cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; } return 0; } 问题三\tEven? Odd? G 问题陈述 Bessie那惨无人道的二年级老师搞了一个有 N 个正整数 I 的表叫Bessie去判断“奇偶性”（这个词语意思向二年级的学生解释，就是“这个数是单数，还是双数啊？”）。Bessie被那个表的长度深深地震惊到了，竟然跟栋栋的泛做表格一样多道题！！！毕竟她才刚刚学会数数啊。\n写一个程序读入N个整数，如果是双数，那么在单立的一行内输出\u0026quot;even\u0026quot;，如果是单数则类似地输出\u0026quot;odd\u0026quot;.\n数据范围：每个正整数不超过 10^60\n解题思路 数据范围远超int 或者long long能表示的范围，但题目仅要求判断奇偶，故以string的方式读入，判断最后一位的奇偶即可。幸运的是，数字的ASCII码的奇偶性与其本身一致，故不需要额外进行处理，AC代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { int N; cin\u0026gt;\u0026gt;N; while(N--) { string s; cin\u0026gt;\u0026gt;s; if(s[s.length()-1]%2) cout\u0026lt;\u0026lt;\u0026#34;odd\u0026#34;\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;even\u0026#34;\u0026lt;\u0026lt;endl; } return 0; } 问题4\tProblem Generator 问题陈述 Vlad计划下个月举办m轮比赛。每一轮比赛应包含难度等级为\u0026rsquo;A\u0026rsquo;, \u0026lsquo;B\u0026rsquo;, \u0026lsquo;C\u0026rsquo;, \u0026lsquo;D\u0026rsquo;, \u0026lsquo;E\u0026rsquo;, \u0026lsquo;F\u0026rsquo;, 和 \u0026lsquo;G\u0026rsquo; 的一个问题。\nVlad已经准备了n个问题，其中第i个问题的难度等级为a(i)。可能这些问题数量不够，所以他可能需要再想出一些问题。\nVlad希望尽可能少地想出问题，因此他请你找出他需要想出的问题的最少数量，以便举办m轮比赛。\n例如，如果m=1，n=10，a= \u0026lsquo;BGECDCBDED\u0026rsquo;，那么他需要想出两个问题：一个难度等级为\u0026rsquo;A\u0026rsquo;，一个难度等级为\u0026rsquo;F\u0026rsquo;。\n解题思路 依题意，每种问题需要m个，故读入m、n，计算每种问题已有数量和总共所需之差再求和即可（缺少的问题\u0026lt;0的不计），AC代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int t; cin\u0026gt;\u0026gt;t; while(t--) { int n; int m; char c; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; int cnt[]={m,m,m,m,m,m,m}; int ans=0; while(n--) { cin\u0026gt;\u0026gt;c; cnt[c-65]--; } for(int i=0;i\u0026lt;7;i++) if(cnt[i]\u0026gt;0) ans+=cnt[i]; cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } 问题五\trules 问题陈述 小 A 制定了一些规则，每条规则有一个代号，代号为不超过 10^9的非负整数。\n小 A 的国家有 n位居民，每位居民每天会且仅会遵守 1条规则。小 A 记录了 m天里每天每位居民遵守的规则代号。\n现在小 A 想要考察代号为 k的规则是否符合民意，具体考察方法如下：\n如果在某一天里，有大于等于一半的人遵守了规则 k，那么小 A 认为在这一天规则 k是符合民意的。 如果在大于等于一半的天数里，规则 k符合民意，那么他会认为规则 k是正确的。否则，他会认为规则 k是错误的。 如果小 A 的规则 k是正确的，请你输出 YES，否则请你输出 NO。\n解题思路 分别计算每一天遵循该规则的居民数量是否大于等于总数的一半，最后再计算符合民意的天数是否大于等于m的一半即可（实现方法使用的是将遵循规则的居民数量、符合民意的天数乘以2与总居民数、m进行比较，不需要引入float类型，乘法比除法更快），AC代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int n,m,k; int cntt=0; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; for(int z=0;z\u0026lt;m;z++) { int cntd=0; for(int i=0;i\u0026lt;n;i++) { int d; cin\u0026gt;\u0026gt;d; cntd += d==k; } cntt += 2*cntd\u0026gt;=n; } if(2*cntt\u0026gt;=m) cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; return 0; } 问题六\tMany Replacement 问题陈述 给定一个长度为 N的字符串 S，由小写英文字母组成。\n你将对字符串 S 执行 Q 次操作。 第 i次操作 (1≤i≤Q)由一对字符 (c(i),d(i)) 表示，对应以下操作：\n将字符串 S中所有字符 c(i)替换为字符 d(i)。 在所有操作完成后，打印字符串 S。\n约束条件 1≤N≤2×10^5 S是一个长度为 N的字符串，由小写英文字母组成。 1≤Q≤2×10^5 c(i)和 d(i)是小写英文字母 (1≤i≤Q) N和 Q是整数。 解题思路 在字符串长度较长的情况下，每次都遍历字符串进行修改是不现实的（很有可能会TLE）。发现经过多次交换后，每个字母对应映射到另一字母，那么维护一个字母表（初始映射到自身），每次对字母表的映射进行修改，在最后再遍历字符串进行修改即可，AC代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { int N; string s; int Q; cin\u0026gt;\u0026gt;N\u0026gt;\u0026gt;s\u0026gt;\u0026gt;Q; char Letters[26]; for(int i=0;i\u0026lt;26;i++) Letters[i]=i+\u0026#39;a\u0026#39;; while(Q--) { char c,d; cin\u0026gt;\u0026gt;c\u0026gt;\u0026gt;d; for(int i=0;i\u0026lt;26;i++) { if(Letters[i]==c) { Letters[i]=d; } } } for(int i=0;i\u0026lt;N;i++) { s[i]=Letters[s[i]-\u0026#39;a\u0026#39;]; } cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;endl; return 0; } 问题七\t更好的交换 问题陈述 小 S 有一个奇怪的机关拼图。这个拼图可以看作一个 n行 n列的方阵 A，第 i行第 j列的位置上有一个正整数 A(i,j)。\n与寻常拼图不同的是，这个机关拼图上的数字不能随意移动，必须按照如下规则之一操作：\n选择拼图上的第 x行和第 y行，交换这两行； 选择拼图上的第 x列和第 y列，交换这两列。 为了复原这个拼图，小 S 将会操作共 m次，每次操作格式如下：\n1 x y，表示交换第 x行和第 y行； 0 x y，表示交换第 x列和第 y列； 请你输出复原后的拼图。\n解题思路 发现并不需要实际地交换行和列，只需要维护两个数组Row、Col，对数组中行与列映射代表的行与列关系进行修改即可，与上一题其实类似。AC代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; using namespace std; int Matrix[1002][1002]; int Row[1002],Col[1002]; int main() { int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++) { for(int j=1;j\u0026lt;=n;j++) { cin\u0026gt;\u0026gt;Matrix[i][j]; } } for(int i=1;i\u0026lt;=n;i++) Row[i]=Col[i]=i; while(m--) { int op,x,y; cin\u0026gt;\u0026gt;op\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; if(op) swap(Row[x],Row[y]); else swap(Col[x],Col[y]); } for(int i=1;i\u0026lt;=n;i++) { for(int j=1;j\u0026lt;=n;j++) { cout\u0026lt;\u0026lt;Matrix[Row[i]][Col[j]]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; } return 0; } 学习总结 本专题内容主要为C++基础语法，通过学习，对时间复杂度和空间复杂度的计算有了更深入的了解，对STL的内容有了了解。\n","date":"0001-01-01T00:00:00Z","permalink":"https://DustLi-DC.github.io/p/","title":""}]